{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-a34b42c4-42ad-4072-95a1-d2b7eb864e5a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f9fc1bb9-4631-45e0-bd3c-7caedc008f1f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5b5e1f08-4f65-4af8-baff-f634d8e5a990",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `memcpy` function in C++ arises from improper handling of memory copying operations, which can lead to buffer overflows, data corruption, or undefined behavior. The specific issue with the function call `memcpy((void *)param_bo_map, (void *)param, param_size)` is that it does not ensure that the destination buffer `param_bo_map` is large enough to hold the data being copied from `param`. This can result in writing beyond the bounds of the destination buffer, potentially leading to security vulnerabilities such as arbitrary code execution or denial of service.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ that provide better safety guarantees.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other memory-related issues in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\nvoid safe_memcpy(void* dest, size_t dest_size, const void* src, size_t src_size) {\n    if (src_size > dest_size) {\n        std::cerr << \"Error: Source size is greater than destination size. Aborting copy operation.\" << std::endl;\n        return;\n    }\n    memcpy(dest, src, src_size);\n}\n\nint main() {\n    // Example usage\n    char param_bo_map[100]; // Destination buffer\n    char param[50]; // Source buffer\n    size_t param_size = sizeof(param);\n\n    safe_memcpy(param_bo_map, sizeof(param_bo_map), param, param_size);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8d9a0ecc-67c3-4686-9006-7c6e64c6b025",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied, or when the source or destination pointers are invalid. In the provided code snippet, `memcpy(params.data(), kernel_params_, 64)`, the vulnerability may occur if `params` does not have at least 64 bytes of allocated space.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the source and destination pointers are valid and within the expected range.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory-related issues.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the given code snippet, ensure that `params` has enough space and use `std::copy` for safer copying:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <vector>    // for std::vector\n\n// Assuming kernel_params_ is a pointer to the source data\nvoid safeCopy(std::vector<char>& params, const char* kernel_params_) {\n    if (params.size() < 64) {\n        // Resize the vector to ensure it has enough space\n        params.resize(64);\n    }\n    std::copy(kernel_params_, kernel_params_ + 64, params.begin());\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard C++ libraries are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<vector>`: Provides the `std::vector` container.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b36f8702-6c27-49da-91d8-b118f99f36e7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy(kernel_params_, kernel_params.data, params_bytes)` is potentially unsafe because it does not perform bounds checking on the destination buffer `kernel_params_`. If `params_bytes` exceeds the size of `kernel_params_`, this can lead to a buffer overflow, which is a common security vulnerability. Buffer overflows can result in undefined behavior, including data corruption, crashes, and security breaches such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Use safer alternatives like `std::copy` or `std::memmove` if applicable.\n2. **Use Safer Functions**: Consider using safer functions like `memcpy_s` if available, which include additional parameters for bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the destination buffer is checked before performing the copy operation. Here is a revised version of the code:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for std::memcpy\n\n// Assuming kernel_params_ is a pointer and kernel_params is a struct or class with a data member\nvoid safeMemcpy(char* kernel_params_, const char* kernel_params_data, size_t params_bytes, size_t kernel_params_size) {\n    if (params_bytes <= kernel_params_size) {\n        std::memcpy(kernel_params_, kernel_params_data, params_bytes);\n    } else {\n        // Handle error: buffer overflow risk\n        // This could be logging the error, throwing an exception, etc.\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: For using `std::copy` if needed.\n- `<cstring>`: For using `std::memcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-71b6f53d-3e6e-4ef0-8846-a9e91dc58c84",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f865b08b-d4ee-46f8-8b10-dc807ab9bd92",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-a34b42c4-42ad-4072-95a1-d2b7eb864e5a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 547,
                  "startColumn": 2,
                  "endLine": 548,
                  "endColumn": 49,
                  "charOffset": 20446,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20446,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f9fc1bb9-4631-45e0-bd3c-7caedc008f1f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 2,
                  "endLine": 499,
                  "endColumn": 45,
                  "charOffset": 18466,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18466,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5b5e1f08-4f65-4af8-baff-f634d8e5a990",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function: memcpy\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 484,
                  "startColumn": 2,
                  "endLine": 484,
                  "endColumn": 57,
                  "charOffset": 17881,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy((void *)param_bo_map, (void *)param, param_size)",
                    "rendered": {
                      "text": "memcpy((void *)param_bo_map, (void *)param, param_size)",
                      "markdown": "`memcpy((void *)param_bo_map, (void *)param, param_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17881,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)param_bo_map, <size of (void *)param_bo_map>,  (void *)param,  param_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8d9a0ecc-67c3-4686-9006-7c6e64c6b025",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 369,
                  "startColumn": 2,
                  "endLine": 369,
                  "endColumn": 43,
                  "charOffset": 13672,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(params.data(), kernel_params_, 64)",
                    "rendered": {
                      "text": "memcpy(params.data(), kernel_params_, 64)",
                      "markdown": "`memcpy(params.data(), kernel_params_, 64)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13672,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(params.data(), <size of params.data()>,  kernel_params_,  64)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b36f8702-6c27-49da-91d8-b118f99f36e7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 2,
                  "endLine": 360,
                  "endColumn": 58,
                  "charOffset": 13315,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(kernel_params_, kernel_params.data, params_bytes)",
                    "rendered": {
                      "text": "memcpy(kernel_params_, kernel_params.data, params_bytes)",
                      "markdown": "`memcpy(kernel_params_, kernel_params.data, params_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13315,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(kernel_params_, <size of kernel_params_>,  kernel_params.data,  params_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-71b6f53d-3e6e-4ef0-8846-a9e91dc58c84",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2154,
                  "startColumn": 8,
                  "endLine": 2156,
                  "endColumn": 45,
                  "charOffset": 82896,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82896,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f865b08b-d4ee-46f8-8b10-dc807ab9bd92",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (memcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2070,
                  "startColumn": 8,
                  "endLine": 2072,
                  "endColumn": 45,
                  "charOffset": 79759,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79759,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}